#include <iostream>

// include the librealsense C++ header file
#include <librealsense2/rs.hpp>

// include OpenCV header file
#include <opencv2/opencv.hpp>

#include "merge4Img.h"

using namespace cv;
using namespace std;

//-----------------------------------【全局变量声明部分】--------------------------------------
//		描述：全局变量声明
//---------------------------------------------------------------------------------------------
int g_min_dist = 20;
int g_min_radius = 5;
int g_max_radius = 15;

bool original = 1;
bool RGB = 1;
bool HSV = 1;



//-----------------------------------【全局函数声明部分】--------------------------------------
//		描述：全局函数声明
//-----------------------------------------------------------------------------------------------
void on_Trackbar_g_min_dist(int, void *);//回调函数
void on_Trackbar_g_min_radius(int, void *);//回调函数
void on_Trackbar_g_max_radius(int, void *);//回调函数
void on_Trackbar_g_min_dist(int, void *){}
void on_Trackbar_g_min_radius(int, void *){}
void on_Trackbar_g_max_radius(int, void *){}



void runCanny(cv::Mat &srcImage)
{
	Canny(srcImage, srcImage, 60, 20, 3, 1);
}

void runHC(cv::Mat &srcImage, vector<Vec3f> &circles)
{
	HoughCircles(srcImage, circles, CV_HOUGH_GRADIENT, 3, 20, 100, 40, 5, 15);
}

void runHC(cv::Mat &srcImage, vector<Vec3f> &circles, int min_dist, int min_radius, int max_radius)
{
	HoughCircles(srcImage, circles, CV_HOUGH_GRADIENT, 3, min_dist, 100, 40, min_radius, max_radius);

	/*
	HoughCircles( src_gray, circles, CV_HOUGH_GRADIENT, 1, src_gray.rows/8, 200, 100, 0, 0 );

	with the arguments:

	src_gray: Input image (grayscale)
	circles: A vector that stores sets of 3 values: x_{c}, y_{c}, r for each detected circle.
	CV_HOUGH_GRADIENT: Define the detection method. Currently this is the only one available in OpenCV
	dp = 1: The inverse ratio of resolution
	min_dist = src_gray.rows/8: Minimum distance between detected centers
	param_1 = 200: Upper threshold for the internal Canny edge detector
	param_2 = 100*: Threshold for center detection.
	min_radius = 0: Minimum radio to be detected. If unknown, put zero as default.
	max_radius = 0: Maximum radius to be detected. If unknown, put zero as default
	*/
}

void drawHC(cv::Mat &srcImage, vector<Vec3f> &circles)
{
	for (size_t i = 0; i < circles.size(); i++)
	{
		if ((cvRound(circles[i][0]) >= 40) && (cvRound(circles[i][1]) >= 40) && (cvRound(circles[i][0]) <= (srcImage.size().width - 40)) && ((cvRound(circles[i][1]) <= (srcImage.size().height - 40))))
		{
			Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
			//cout << circles[i][0] << "，" << circles[i][1] << "；" << endl;
			int radius = cvRound(circles[i][2]);
			circle(srcImage, center, 3, Scalar(0, 255, 0), -1, 8, 0);
			circle(srcImage, center, radius, Scalar(155, 50, 255), 3, 8, 0);
		}
	}
}

void runMORPH_OPEN(cv::Mat &srcImage)
{
	Mat element = getStructuringElement(MORPH_RECT, Size(9, 9));
	//进行形态学操作
	morphologyEx(srcImage, srcImage, MORPH_OPEN, element);
}


int main()
{
	//Contruct a pipeline which abstracts the device
	rs2::pipeline pipe;//创建一个通信管道
	//Create a configuration for configuring the pipeline with a non default profile
	rs2::config cfg;//创建一个以非默认配置的配置用来配置管道

	//Add desired streams to configuration
	cfg.enable_stream(RS2_STREAM_COLOR, 640, 480, RS2_FORMAT_BGR8, 30);//向配置添加所需的流
	//彩色图片：分辨率640*480 8位bgr格式 每秒30帧
	//Instruct pipeline to start streaming with the requested configuration
	pipe.start(cfg);//指示管道使用所请求的配置启动流

	// Camera warmup - dropping several first frames to let auto-exposure stabilize
	rs2::frameset frames;//相机预热-删除几个第一帧让自动曝光稳定。
	for (int i = 0; i < 30; i++)
	{
		//Wait for all configured streams to produce a frame
		frames = pipe.wait_for_frames();//等待所有配置的流生成框架

		//Get each frame
		rs2::frame color_frame = frames.get_color_frame();

		// Creating OpenCV Matrix from a color image
		Mat color(Size(640, 480), CV_8UC3, (void*)color_frame.get_data(), Mat::AUTO_STEP);
		imshow("【原始图-color】", color);
		cv::waitKey(10);
	}

	//创建轨迹条
	createTrackbar("g_min_dist", "【原始图-color】", &g_min_dist, 50, on_Trackbar_g_min_dist);
	createTrackbar("g_min_radius", "【原始图-color】", &g_min_radius, 50, on_Trackbar_g_min_radius);
	createTrackbar("g_max_radius", "【原始图-color】", &g_max_radius, 100, on_Trackbar_g_max_radius);

	while(cv::waitKey(1) != 'q')
	{
		//Wait for all configured streams to produce a frame
		frames = pipe.wait_for_frames();//等待所有配置的流生成框架
		
		//Get each frame
		rs2::frame color_frame = frames.get_color_frame();

		// Creating OpenCV Matrix from a color image
		Mat color(Size(640, 480), CV_8UC3, (void*)color_frame.get_data(), Mat::AUTO_STEP);
		imshow("【原始图-color】", color);

		if (original)
		{
			Mat srcImage;
			color.copyTo(srcImage);
			//imshow("【原始图】", srcImage);

			cv::Mat midImage;
			srcImage.copyTo(midImage);
			cvtColor(midImage, midImage, CV_BGR2GRAY);
			//imshow("【灰度图】", midImage);

			Mat BlurImage;
			midImage.copyTo(BlurImage);
			GaussianBlur(BlurImage, BlurImage, Size(9, 9), 2, 2);
			//imshow("【模糊图】", BlurImage);

			Mat CannyImage;
			BlurImage.copyTo(CannyImage);
			runCanny(CannyImage);
			//imshow("【Canny边缘检测效果图】", CannyImage);

			vector<Vec3f> circles;
			Mat HoughImage;
			srcImage.copyTo(HoughImage);

			runHC(CannyImage, circles, g_min_dist, g_min_radius, g_max_radius);
			//runHC(CannyImage, circles);
			drawHC(HoughImage, circles);
			//imshow("【效果图】", HoughImage);

			cv::Mat dst;
			cvtColor(BlurImage, BlurImage, CV_GRAY2BGR);
			cvtColor(CannyImage, CannyImage, CV_GRAY2BGR);
			merge4Img(dst, srcImage, BlurImage, CannyImage, HoughImage);
			imshow("【原图处理】", dst);
			waitKey(1);
		}

		if (RGB) 
		{
			Mat srcImageRGB;
			color.copyTo(srcImageRGB);
			vector<Mat> channels;
			vector<Mat> mbgr(3);
			split(srcImageRGB, channels);
			Mat B = channels.at(0);
			Mat G = channels.at(1);
			Mat R = channels.at(2);
			
			Mat bk1(srcImageRGB.size(), CV_8UC1, Scalar(0));
			Mat imageB(srcImageRGB.size(), CV_8UC3);
			mbgr[0] = B;
			mbgr[1] = bk1;
			mbgr[2] = bk1;
			merge(mbgr, imageB);
			
			//imshow("原图", srcImageRGB);
			//imshow("imageB", imageB);
			//imshow("B", B);//imshow("G", G);//imshow("R", R);

			Mat MORPH_OPEN_R;
			R.copyTo(MORPH_OPEN_R);
			runMORPH_OPEN(MORPH_OPEN_R);
			//imshow("【效果图】形态学梯度", MORPH_OPEN_R);
			
			Mat BlurImage;
			MORPH_OPEN_R.copyTo(BlurImage);
			GaussianBlur(BlurImage, BlurImage, Size(9, 9), 2, 2);
			//imshow("【模糊图】", BlurImage);

			Mat CannyImage;
			BlurImage.copyTo(CannyImage);
			runCanny(CannyImage);
			//imshow("【Canny边缘检测效果图】", CannyImage);

			vector<Vec3f> circles;
			Mat HoughImage;
			color.copyTo(HoughImage);

			runHC(CannyImage, circles, g_min_dist, g_min_radius, g_max_radius);
			//runHC(CannyImage, circles);

			drawHC(HoughImage, circles);
			//imshow("【效果图】", HoughImage);
	
			cv::Mat dst;
			cvtColor(BlurImage, BlurImage, CV_GRAY2BGR);
			cvtColor(CannyImage, CannyImage, CV_GRAY2BGR);
			merge4Img(dst, srcImageRGB, BlurImage, CannyImage, HoughImage);
			imshow("【R 通道处理】", dst);
			waitKey(1);

		}

		if (HSV)
		{
			Mat srcImageHSV;
			color.copyTo(srcImageHSV);

			Mat src_hsv;
			cvtColor(srcImageHSV, src_hsv, CV_BGR2HSV_FULL);
			//cvtColor(srcImageRGB, src_hsv, CV_BGR2HSV);

			vector<Mat> hsv_channels;
			split(src_hsv, hsv_channels);
			Mat H = hsv_channels.at(0);
			Mat S = hsv_channels.at(1);
			Mat V = hsv_channels.at(2);
			
			//imshow("H", H);
			//imshow("S", S);
			//imshow("V", V);

			Mat MORPH_OPEN_H;
			H.copyTo(MORPH_OPEN_H);
			runMORPH_OPEN(MORPH_OPEN_H);
			//imshow("【效果图】形态学梯度", MORPH_OPEN_H);

			Mat BlurImage;
			MORPH_OPEN_H.copyTo(BlurImage);
			GaussianBlur(BlurImage, BlurImage, Size(9, 9), 2, 2);
			//imshow("【模糊图】", BlurImage);

			Mat CannyImage;
			BlurImage.copyTo(CannyImage);
			runCanny(CannyImage);
			//imshow("【Canny边缘检测效果图】", CannyImage);

			vector<Vec3f> circles;
			Mat HoughImage;
			color.copyTo(HoughImage);

			runHC(CannyImage, circles, g_min_dist, g_min_radius, g_max_radius);
			//runHC(CannyImage, circles);

			drawHC(HoughImage, circles);
			//imshow("【效果图】", HoughImage);

			cv::Mat dst;
			cvtColor(BlurImage, BlurImage, CV_GRAY2BGR);
			cvtColor(CannyImage, CannyImage, CV_GRAY2BGR);
			merge4Img(dst, srcImageHSV, BlurImage, CannyImage, HoughImage);
			imshow("【H 通道处理】", dst);
			waitKey(1);

		}
	}
	return 0;
}